java 数据结构

    1) Array
        Arrays.sort(arr)  Arrays类中方法 给数组排序 时间复杂度 -> O(n log(n))
        
    2) Math
        Integer.MAX_VALUE   最大整数 常用来求最小值赋值
        Integer.MAX_VALUE   最小整数 常用来求最大值赋值



java 运算符
    1)
        &&,||,！          -> 逻辑运算符
        +, -, *, / ,+=    -> 算数运算符
        ^,|,~,&           -> 位逻辑运算符
        <<,>>,>>>         -> 位移运算符
        三元运算符         -> 其他运算符
    2) 位运算
        &(按位与)         &按位与的运算规则是 将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)
            1&1=1 , 1&0=0 , 0&1=0 , 0&0=0  有假则假
            (1) 十进制中的运算
                12 & 8
                0000 0000 0000 1100
                0000 0000 0000 1000
             &——————————————————————————
                0000 0000 0000 1000         有0则0   
        |(按位或)
            1&1=1 , 1&0=1 , 0&1=1 , 0&0=0  有真则真
            (1) 十进制中的运算
                4 | 8
                0000 0000 0000 0100
                0000 0000 0000 1000
             |——————————————————————————
                0000 0000 0000 1100         有1则1   
        ^(异或)  
            A^B if (A==B,0,1)  如果相等返回0 如果不等返回 1
            (1) 十进制中的运算
                31 & 22
                0000 0000 0001 1111
                0000 0000 0001 0110
             ^——————————————————————————
                0000 0000 0000 1001         不等则1
        ~(取反)  
            if(A==0,1,0)       如果A等于0 返回1,等于1,返回0
            (1) 十进制中的运算
                ~123
                0000 0000 0111 1011
             ~——————————————————————————
                1111 1111 1000 0100         0则1,1则0   
                符号位为1        -124
    3) 位移运算符
        << (左移一位)                           (数值较小时可做到*2作用)
        <<< (左移两位)                          (数值较小时可做到*2*2作用)
            1       2^0   0000 0000 0000 0001   初始值
            1<<1    2^1   0000 0000 0000 0010   左移一位
            1<<<1   2^2   0000 0000 0000 0100   左移两位

    exam:       注意：(高位溢出 低位补0,ro)
    1. 左移运算
        short a = 9115      0010 0011 1001 1011         初始值
        a << 1  【0】   <-  0100 0111 0011 0110  <- 补0
            (溢出舍去|)     = 18230                      左移一位
        a << 2  【00】  <-  1000 1110 0110 1100  <- 补0
                            = -29076                 左移两位
        
        2.右移运算  注意: (int是4个字节,32位长度,此处只展示后16位,这个值前16位为0)
        32768             1000 0000 0000 0000     2^15
                            初始值
        32768 >> 1     -> 1000 0000 0000 0000     2^14
                            右移一位
        32768 >> 2     -> 1000 0000 0000 0000     2^13
                            右移两位

    2.1 正数右移  注意：因为右移所以会出现首位补 0|1 所以出现 >>> 无符号右移(无符号右移并不单单是首位补0)
        short a = 9115         0010 0011 1001 1011
        a >> 1           ->    0001 0001 1100 1101  【1】 溢出舍去
                正数补0            = 4557
        a >> 2           ->    0000 1000 1110 0110  【1 1】 溢出舍去
                正数补0          = 2278

    2.2 负数右移
        short a = -32766       1000 0000 0000 0010
        a >> 1           ->    1100 0000 0000 0001  【0】 溢出舍去
                负数补1            = -16383
        a >> 2           ->    1110 0000 0000 0000  【1 0】 溢出舍去
                正数补1            = -8192

    2.3 无符号右移 >>>
                    1111 1111 1111 1111 1000 0000 0000 0010
                                    初始值      = 32766
                    0111 1111 1111 1111 1100 0000 0000 0001   【0】    溢出舍去
            补0 ->               无符号右移一位  = 2147467265
                    0011 1111 1111 1111 1110 0000 0000 0000   【1 0】  溢出舍去
            补0 ->               无符号右移两位  = 1073733632
        注意
            byte a = (byte)(-32>>>1)       = -16       
            short b = (short)(-128>>>4)    = -8        
            因为byte short属于低精度整形 所以不适合做无符号右移 否则结果会溢出